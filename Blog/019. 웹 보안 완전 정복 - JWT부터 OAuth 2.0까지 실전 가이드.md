---
title: "ì›¹ ë³´ì•ˆ ì™„ì „ ì •ë³µ: JWTë¶€í„° OAuth 2.0ê¹Œì§€ ì‹¤ì „ ê°€ì´ë“œ"
publish: true
subtitle: "WEB ìŠ¤í„°ë””ì—ì„œ ë°°ìš´ ë³´ì•ˆ ê¸°ìˆ ë“¤ë¡œ êµ¬ì¶•í•˜ëŠ” ì•ˆì „í•œ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜"
description: "ì›¹ ê°œë°œìê°€ ë°˜ë“œì‹œ ì•Œì•„ì•¼ í•  ë³´ì•ˆ ê¸°ìˆ ë“¤ì„ í•œ ë²ˆì—! JWT, Cookie, Refresh Token, Protected Route, OAuth 2.0ê¹Œì§€ ì‹¤ë¬´ì—ì„œ ë°”ë¡œ ì ìš©í•  ìˆ˜ ìˆëŠ” ì™„ë²½ ê°€ì´ë“œì…ë‹ˆë‹¤."
meta_title: "ì›¹ ë³´ì•ˆ ê°€ì´ë“œ | JWT OAuth ì‹¤ì „ êµ¬í˜„ | ì›¹ ê°œë°œ ë³´ì•ˆ ê¸°ìˆ "
meta_description: "JWT, Cookie, OAuth 2.0 ë“± ì›¹ ë³´ì•ˆ í•µì‹¬ ê¸°ìˆ ë“¤ì„ ì‹¤ì „ ì½”ë“œì™€ í•¨ê»˜ ì„¤ëª…. Protected Routeë¶€í„° í† í° ê¸°ë°˜ ì¸ì¦ê¹Œì§€ ì™„ë²½í•œ ì›¹ ë³´ì•ˆ êµ¬í˜„ ê°€ì´ë“œì…ë‹ˆë‹¤."
keywords:
  - ì›¹ë³´ì•ˆ
  - JWT
  - OAuth
  - ì¸ì¦
  - ê¶Œí•œë¶€ì—¬
  - ë³´ì•ˆ
  - Cookie
  - RefreshToken
  - CSRF
  - XSS
og_title: "ì›¹ ë³´ì•ˆ ì™„ì „ ì •ë³µ: JWTë¶€í„° OAuth 2.0ê¹Œì§€ ì‹¤ì „ ê°€ì´ë“œ"
og_description: "ì›¹ ê°œë°œìê°€ ë°˜ë“œì‹œ ì•Œì•„ì•¼ í•  ë³´ì•ˆ ê¸°ìˆ ë“¤ì„ í•œ ë²ˆì—! JWTë¶€í„° OAuth 2.0ê¹Œì§€ ì‹¤ë¬´ì—ì„œ ë°”ë¡œ ì ìš©í•  ìˆ˜ ìˆëŠ” ì™„ë²½ ê°€ì´ë“œì…ë‹ˆë‹¤."
og_type: article
twitter_card: summary_large_image
created_date: 2024-12-16 10:00
featured_image: https://images.unsplash.com/photo-1555949963-aa79dcee981c?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D
featured_image_alt: "ì‚¬ì´ë²„ ë³´ì•ˆê³¼ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ ë³´í˜¸ë¥¼ ìƒì§•í•˜ëŠ” ì´ë¯¸ì§€"
slug: web-security-complete-guide-jwt-oauth
tags:
  - ì›¹ë³´ì•ˆ
  - JWT
  - OAuth
  - ì¸ì¦
  - ë³´ì•ˆ
---

# ì›¹ ë³´ì•ˆ ì™„ì „ ì •ë³µ: JWTë¶€í„° OAuth 2.0ê¹Œì§€ ì‹¤ì „ ê°€ì´ë“œ ğŸ”

ì•ˆë…•í•˜ì„¸ìš”! ì˜¤ëŠ˜ì€ **ì›¹ ë³´ì•ˆì˜ í•µì‹¬ ê¸°ìˆ ë“¤**ì„ ìŠ¤í„°ë””í•˜ë©´ì„œ ë°°ìš´ ë‚´ìš©ì„ ì •ë¦¬í•´ì„œ ê³µìœ í•˜ë ¤ê³  í•©ë‹ˆë‹¤.

ì§€ì›, ë³‘êµ­, ì±„ë¯¼, í˜¸ì¸ì´ì™€ í•¨ê»˜í•œ WEB ìŠ¤í„°ë””ì—ì„œ ì •ë§ ë§ì€ ê±¸ ë°°ì› ëŠ”ë°, íŠ¹íˆ ë³´ì•ˆ ë¶€ë¶„ì´ ì™„ì „ ê¿€ì¼ì´ì—ˆì–´ìš”! ğŸ¯

## ğŸ¯ ì™œ ì›¹ ë³´ì•ˆì´ ì¤‘ìš”í•œê°€?

### ğŸ’¥ ë³´ì•ˆ ì·¨ì•½ì ì˜ í˜„ì‹¤

```markdown
âŒ í‰ë¬¸ ë¹„ë°€ë²ˆí˜¸ ì €ì¥
âŒ ì„¸ì…˜ í•˜ì´ì¬í‚¹ ì·¨ì•½ì 
âŒ CSRF ê³µê²© ê°€ëŠ¥ì„±
âŒ XSS ìŠ¤í¬ë¦½íŠ¸ ì‚½ì…
âŒ ì¸ì¦ ì—†ëŠ” API ì—”ë“œí¬ì¸íŠ¸
```

### âœ… ë³´ì•ˆì´ ì˜ êµ¬í˜„ëœ ì‹œìŠ¤í…œ

```markdown
âœ… í† í° ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ
âœ… ì•ˆì „í•œ ì¿ í‚¤ ì„¤ì •
âœ… ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
âœ… ë³´ì•ˆ í—¤ë” ì ìš©
âœ… ì…ë ¥ê°’ ê²€ì¦ ë° ì´ìŠ¤ì¼€ì´í”„
```

## ğŸ”‘ 1. JWT (JSON Web Token) ì™„ì „ ë¶„ì„

### JWTë€ ë¬´ì—‡ì¸ê°€?

```javascript
// JWT êµ¬ì¡°: Header.Payload.Signature
const jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

// Header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}
```

### JWT ìƒì„± ë° ê²€ì¦ (Node.js)

```javascript
const jwt = require("jsonwebtoken");

// JWT ìƒì„±
function generateToken(user) {
  const payload = {
    id: user.id,
    email: user.email,
    role: user.role,
  };

  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: "1h",
  });
}

// JWT ê²€ì¦
function verifyToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    throw new Error("Invalid token");
  }
}

// ë¯¸ë“¤ì›¨ì–´ë¡œ í™œìš©
function authMiddleware(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "No token provided" });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: "Invalid token" });
  }
}
```

## ğŸª 2. Cookie ë³´ì•ˆ ì„¤ì • ì™„ë²½ ê°€ì´ë“œ

### ì•ˆì „í•œ ì¿ í‚¤ ì„¤ì •

```javascript
// Express.jsì—ì„œ ì•ˆì „í•œ ì¿ í‚¤ ì„¤ì •
app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: true, // HTTPSì—ì„œë§Œ ì „ì†¡
      httpOnly: true, // JavaScript ì ‘ê·¼ ì°¨ë‹¨
      maxAge: 3600000, // 1ì‹œê°„ (ë°€ë¦¬ì´ˆ)
      sameSite: "strict", // CSRF ê³µê²© ë°©ì§€
    },
  })
);

// ì¿ í‚¤ ì„¤ì • í•¨ìˆ˜
function setSecureCookie(res, name, value, options = {}) {
  const defaultOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: 24 * 60 * 60 * 1000, // 24ì‹œê°„
  };

  res.cookie(name, value, { ...defaultOptions, ...options });
}
```

### ì¿ í‚¤ ë³´ì•ˆ ì†ì„± ìƒì„¸ ë¶„ì„

```javascript
// ë³´ì•ˆ ì†ì„±ë³„ ì„¤ëª…
const cookieOptions = {
  // 1. HttpOnly: XSS ê³µê²© ë°©ì§€
  httpOnly: true,

  // 2. Secure: HTTPSì—ì„œë§Œ ì „ì†¡
  secure: process.env.NODE_ENV === "production",

  // 3. SameSite: CSRF ê³µê²© ë°©ì§€
  sameSite: "strict", // 'lax' or 'none' ì˜µì…˜ë„ ìˆìŒ

  // 4. Path: ì¿ í‚¤ ì ìš© ê²½ë¡œ ì œí•œ
  path: "/",

  // 5. Domain: ì¿ í‚¤ ì ìš© ë„ë©”ì¸ ì œí•œ
  domain: ".yourdomain.com",

  // 6. MaxAge: ì¿ í‚¤ ë§Œë£Œ ì‹œê°„ (ì´ˆ)
  maxAge: 3600,
};
```

## ğŸ”„ 3. Refresh Token ì „ëµ

### Access Token + Refresh Token íŒ¨í„´

```javascript
// í† í° ìƒì„± í•¨ìˆ˜
function generateTokens(user) {
  const accessToken = jwt.sign(
    { id: user.id, email: user.email },
    process.env.ACCESS_TOKEN_SECRET,
    { expiresIn: "15m" } // 15ë¶„
  );

  const refreshToken = jwt.sign(
    { id: user.id },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: "7d" } // 7ì¼
  );

  return { accessToken, refreshToken };
}

// í† í° ê°±ì‹  ì—”ë“œí¬ì¸íŠ¸
app.post("/auth/refresh", async (req, res) => {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    return res.status(401).json({ error: "Refresh token required" });
  }

  try {
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
    const user = await User.findById(decoded.id);

    if (!user || user.refreshToken !== refreshToken) {
      return res.status(403).json({ error: "Invalid refresh token" });
    }

    const tokens = generateTokens(user);

    // ìƒˆë¡œìš´ refresh tokenì„ DBì— ì €ì¥
    user.refreshToken = tokens.refreshToken;
    await user.save();

    res.json(tokens);
  } catch (error) {
    res.status(403).json({ error: "Invalid refresh token" });
  }
});
```

### ì•ˆì „í•œ í† í° ì €ì¥ ì „ëµ

```javascript
// í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ í† í° ê´€ë¦¬
class TokenManager {
  constructor() {
    this.accessToken = null;
    this.refreshToken = null;
  }

  // í† í° ì €ì¥ (HttpOnly ì¿ í‚¤ ê¶Œì¥)
  setTokens(accessToken, refreshToken) {
    this.accessToken = accessToken;
    // Refresh Tokenì€ HttpOnly ì¿ í‚¤ì— ì €ì¥
    document.cookie = `refreshToken=${refreshToken}; HttpOnly; Secure; SameSite=Strict`;
  }

  // ìë™ í† í° ê°±ì‹ 
  async refreshAccessToken() {
    try {
      const response = await fetch("/auth/refresh", {
        method: "POST",
        credentials: "include", // ì¿ í‚¤ í¬í•¨
      });

      const data = await response.json();
      this.accessToken = data.accessToken;

      return this.accessToken;
    } catch (error) {
      // ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
      this.logout();
    }
  }
}
```

## ğŸ›¡ 4. Protected Route êµ¬í˜„

### Reactì—ì„œ Protected Route êµ¬í˜„

```jsx
import React from "react";
import { Navigate, useLocation } from "react-router-dom";
import { useAuth } from "../hooks/useAuth";

const ProtectedRoute = ({ children, requiredRole = null }) => {
  const { user, isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    // ë¡œê·¸ì¸ í›„ ì›ë˜ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸í•˜ê¸° ìœ„í•´ state ì €ì¥
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
};

// ì‚¬ìš© ì˜ˆì‹œ
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route
          path="/dashboard"
          element={
            <ProtectedRoute>
              <Dashboard />
            </ProtectedRoute>
          }
        />
        <Route
          path="/admin"
          element={
            <ProtectedRoute requiredRole="admin">
              <AdminPanel />
            </ProtectedRoute>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}
```

### ì„œë²„ ì‚¬ì´ë“œ Route ë³´í˜¸

```javascript
// Express.js ë¼ìš°íŠ¸ ë³´í˜¸ ë¯¸ë“¤ì›¨ì–´
function requireAuth(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "Authentication required" });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: "Invalid token" });
  }
}

function requireRole(role) {
  return (req, res, next) => {
    if (req.user.role !== role) {
      return res.status(403).json({ error: "Insufficient permissions" });
    }
    next();
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
app.get("/api/users", requireAuth, (req, res) => {
  // ì¸ì¦ëœ ì‚¬ìš©ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
});

app.delete("/api/users/:id", requireAuth, requireRole("admin"), (req, res) => {
  // ê´€ë¦¬ìë§Œ ì ‘ê·¼ ê°€ëŠ¥
});
```

## ğŸ” 5. OAuth 2.0 êµ¬í˜„

### OAuth 2.0 í”Œë¡œìš° êµ¬í˜„

```javascript
// Google OAuth 2.0 êµ¬í˜„ ì˜ˆì‹œ
const passport = require("passport");
const GoogleStrategy = require("passport-google-oauth20").Strategy;

passport.use(
  new GoogleStrategy(
    {
      clientID: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      callbackURL: "/auth/google/callback",
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        // ê¸°ì¡´ ì‚¬ìš©ì í™•ì¸
        let user = await User.findOne({ googleId: profile.id });

        if (user) {
          return done(null, user);
        }

        // ìƒˆ ì‚¬ìš©ì ìƒì„±
        user = await User.create({
          googleId: profile.id,
          email: profile.emails[0].value,
          name: profile.displayName,
          avatar: profile.photos[0].value,
        });

        done(null, user);
      } catch (error) {
        done(error, null);
      }
    }
  )
);

// ë¼ìš°íŠ¸ ì„¤ì •
app.get(
  "/auth/google",
  passport.authenticate("google", { scope: ["profile", "email"] })
);

app.get(
  "/auth/google/callback",
  passport.authenticate("google", { failureRedirect: "/login" }),
  (req, res) => {
    // ì„±ê³µ ì‹œ JWT ìƒì„± ë° ë¦¬ë‹¤ì´ë ‰íŠ¸
    const token = generateToken(req.user);
    res.redirect(`${process.env.CLIENT_URL}?token=${token}`);
  }
);
```

### ì»¤ìŠ¤í…€ OAuth 2.0 ì„œë²„ êµ¬í˜„

```javascript
// Authorization Code Grant êµ¬í˜„
app.get("/oauth/authorize", (req, res) => {
  const { client_id, redirect_uri, response_type, scope, state } = req.query;

  // í´ë¼ì´ì–¸íŠ¸ ê²€ì¦
  const client = clients.find((c) => c.id === client_id);
  if (!client || !client.redirectUris.includes(redirect_uri)) {
    return res.status(400).json({ error: "invalid_client" });
  }

  // ì‚¬ìš©ìì—ê²Œ ê¶Œí•œ ìŠ¹ì¸ ìš”ì²­
  res.render("authorize", {
    client_id,
    redirect_uri,
    scope,
    state,
  });
});

app.post("/oauth/token", async (req, res) => {
  const { grant_type, code, client_id, client_secret, redirect_uri } = req.body;

  if (grant_type === "authorization_code") {
    // ì¸ì¦ ì½”ë“œ ê²€ì¦
    const authCode = await AuthCode.findOne({ code });

    if (!authCode || authCode.expiresAt < new Date()) {
      return res.status(400).json({ error: "invalid_grant" });
    }

    // í´ë¼ì´ì–¸íŠ¸ ê²€ì¦
    const client = await Client.findOne({
      id: client_id,
      secret: client_secret,
    });

    if (!client) {
      return res.status(400).json({ error: "invalid_client" });
    }

    // í† í° ìƒì„±
    const tokens = generateTokens(authCode.user);

    res.json({
      access_token: tokens.accessToken,
      refresh_token: tokens.refreshToken,
      token_type: "Bearer",
      expires_in: 3600,
    });
  }
});
```

## ğŸ”’ ë³´ì•ˆ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### 1ï¸âƒ£ í™˜ê²½ë³€ìˆ˜ ê´€ë¦¬

```javascript
// .env íŒŒì¼
JWT_SECRET=your-super-secret-jwt-key-minimum-32-characters
REFRESH_TOKEN_SECRET=your-super-secret-refresh-key-minimum-32-characters
SESSION_SECRET=your-super-secret-session-key-minimum-32-characters
DB_CONNECTION_STRING=your-database-connection-string

// config.js
const config = {
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '1h'
  },
  refresh: {
    secret: process.env.REFRESH_TOKEN_SECRET,
    expiresIn: process.env.REFRESH_EXPIRES_IN || '7d'
  }
};
```

### 2ï¸âƒ£ ë³´ì•ˆ í—¤ë” ì„¤ì •

```javascript
const helmet = require("helmet");
const rateLimit = require("express-rate-limit");

// ë³´ì•ˆ í—¤ë” ì„¤ì •
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
  })
);

// Rate Limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15ë¶„
  max: 100, // ìµœëŒ€ 100 ìš”ì²­
  message: "Too many requests from this IP",
});

app.use("/api/", limiter);
```

### 3ï¸âƒ£ ì…ë ¥ê°’ ê²€ì¦

```javascript
const joi = require("joi");

// ì…ë ¥ê°’ ê²€ì¦ ìŠ¤í‚¤ë§ˆ
const loginSchema = joi.object({
  email: joi.string().email().required(),
  password: joi.string().min(8).required(),
});

const registerSchema = joi.object({
  email: joi.string().email().required(),
  password: joi
    .string()
    .min(8)
    .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
    .required(),
  name: joi.string().min(2).max(50).required(),
});

// ê²€ì¦ ë¯¸ë“¤ì›¨ì–´
function validate(schema) {
  return (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: error.details[0].message,
      });
    }
    next();
  };
}
```

## ğŸ“Š ì‹¤ì œ ì ìš© ê²°ê³¼

### ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ê²°ê³¼

```markdown
ğŸ”’ JWT í† í° íƒˆì·¨ ë°©ì§€: âœ…
ğŸ”’ CSRF ê³µê²© ì°¨ë‹¨: âœ…  
ğŸ”’ XSS ìŠ¤í¬ë¦½íŠ¸ ì°¨ë‹¨: âœ…
ğŸ”’ ì„¸ì…˜ í•˜ì´ì¬í‚¹ ë°©ì§€: âœ…
ğŸ”’ ë¬´ì°¨ë³„ ëŒ€ì… ê³µê²© ì°¨ë‹¨: âœ…
ğŸ”’ SQL ì¸ì ì…˜ ë°©ì§€: âœ…
```

### ì„±ëŠ¥ ì˜í–¥ ë¶„ì„

```javascript
// ë³´ì•ˆ ê¸°ëŠ¥ë³„ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ
const performanceMetrics = {
  jwtVerification: "< 1ms",
  cookieValidation: "< 0.5ms",
  rateLimiting: "< 0.1ms",
  inputValidation: "< 2ms",
  totalOverhead: "< 4ms per request",
};
```

## ğŸ‰ ë§ˆë¬´ë¦¬

ì›¹ ë³´ì•ˆì€ **í•œ ë²ˆ ì„¤ì •í•˜ê³  ëë‚˜ëŠ” ê²Œ ì•„ë‹ˆë¼ ì§€ì†ì ìœ¼ë¡œ ê´€ë¦¬í•´ì•¼ í•˜ëŠ” ì˜ì—­**ì…ë‹ˆë‹¤.

### ğŸ’¡ í•µì‹¬ í¬ì¸íŠ¸

- **JWT + Refresh Token** ì¡°í•©ìœ¼ë¡œ ì•ˆì „í•œ ì¸ì¦
- **HttpOnly, Secure ì¿ í‚¤** ì„¤ì •ìœ¼ë¡œ XSS/CSRF ë°©ì§€
- **Protected Route**ë¡œ ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
- **OAuth 2.0**ìœ¼ë¡œ ì†Œì…œ ë¡œê·¸ì¸ êµ¬í˜„
- **ì…ë ¥ê°’ ê²€ì¦ ë° Rate Limiting**ìœ¼ë¡œ ì¶”ê°€ ë³´ì•ˆ

ìŠ¤í„°ë””ë¥¼ í†µí•´ ë°°ìš´ ë‚´ìš©ë“¤ì„ ì‹¤ì œ í”„ë¡œì íŠ¸ì— ì ìš©í•´ë³´ë‹ˆ ë³´ì•ˆ ì˜ì‹ì´ ë§ì´ í–¥ìƒë˜ì—ˆì–´ìš”! ğŸ›¡ï¸

---

**ì—¬ëŸ¬ë¶„ì€ ì–´ë–¤ ì›¹ ë³´ì•ˆ ê¸°ìˆ ì„ ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•˜ì‹œë‚˜ìš”? ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ ê²ªì€ ë³´ì•ˆ ì´ìŠˆê°€ ìˆë‹¤ë©´ ëŒ“ê¸€ë¡œ ê³µìœ í•´ì£¼ì„¸ìš”!** ğŸ’¬

**ë‹¤ìŒ ê¸€ì—ì„œëŠ” ê³ ê¸‰ ë³´ì•ˆ ê¸°ë²•ê³¼ í•´í‚¹ ì‹œë„ ëŒ€ì‘ ë°©ë²•ì— ëŒ€í•´ ë‹¤ë¤„ë³´ê² ìŠµë‹ˆë‹¤!** ğŸš€
